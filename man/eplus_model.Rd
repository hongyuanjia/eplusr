% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eplus_model.R
\docType{class}
\name{eplus_model}
\alias{eplus_model}
\title{Read, modify, save, run and analyze EnergyPlus models}
\format{An object of class \code{R6ClassGenerator} of length 24.}
\usage{
eplus_model
}
\description{
IDFEditor distributed along with
\href{https://www.energyplus.net}{EnergyPlus} provides full support for
preparing EnergyPus IDF and IMF files for simulations. The parsing and
writing process of IDF and IDD files in \code{eplusr} is basically the same
as that in IDFEditor. But \code{eplusr} takes advantage of the powerful
\code{data.table} package to speed up the whole process and store the
results. The IDD files for EnergyPlus 8.0 to 8.8 have been pre-parsed and
stored internally and will automatically be used when parsing \code{IDF} and
\code{IMF} files. The souce codes of IDFEditor can be found on
\href{https://github.com/NREL/EnergyPlus/tree/develop/src/IDF_Editor}{GitHub}
. There is still an option to give an additional IDD file path to parse if
you want. However, it will still take about 3-4 sec to parse an IDD file
which is much slower than IDFEditor written in Visual Basic.
}
\details{
Basically, all model data are stored as \code{data.table}s. And each object
in the model has an unique \strong{\code{ID}}. Once you have the object ID,
you can set fields (using \code{$set}) in the object, duplicate (using
\code{$dup}), delete (using \code{del}) the object.
}
\section{Usage}{
\preformatted{model <- eplus_model$new(path, idd = NULL)

model$all(type, class = NULL)
model$contains(match, scale)
model$matches(match, ..., scale)
model$get(...)
model$add(class, ..., min = TRUE)
model$set(id, ...)
model$dup(id, new_name = NULL)
model$del(id, force = FALSE)
model$diff(type)
model$check()
model$save(comfirm = FALSE, format)
model$saveas(path, format, overwrite = FALSE)
model$print()
model$reset(comfirm = FALSE)
}
}

\section{Read}{
\preformatted{model <- eplus_model$new(path, idd = NULL)
}
\itemize{
\item \code{path}: Path to EnergyPlus \code{IDF} or \code{IMF} file. The file extension does not
matter. So models stored in \code{TXT} file are still able to correctly be
parsed.
\item \code{idd}: Path to \code{Energy+.idd} file. If NULL, the pre-parsed \code{Energy+.idd}
files stored internally from EnergyPlus v8.0 to 8.8 will be used.
}
}

\section{Query}{
\preformatted{model$all(type, class = NULL)
model$contains(match, scale)
model$matches(match, ..., scale)
model$get(...)
}

\code{$all} will give you all valid components you specified using \code{type} in
current model for type "id" and "class". You can find all available fields
for all valid class in IDD using \code{$all(type = "field", class = "any_valid_class_in_IDD")} which makes it handy to be used along with
\code{$add}.

\code{$contains} and \code{$matches} will search and return objects that contain the
string or match the regular expression you give.

\code{$get} will return you the objects with valid IDs you give.

\strong{Arguments}
\itemize{
\item \code{model}: An \code{eplus_model} object.
\item \code{type}: Should be one of "id", "class" and "field". "id" will give you all
object IDs in current model. "class" will give you all classes
existed in current model. "field" will give you all valid fields in
the class with required fields marked with "*".
\item \code{class}: An valid class name. Only required when \code{type} is set to "field".
you can find all valid class names using \code{$all("class")}.
\item \code{match}: A string for \code{$contains} and a regular expression for \code{$matches}
you want to search or match. All \code{...} in \code{$matches} will be
parsed to \code{grepl}. See \code{\link{grepl}}.
\item \code{scale}: Where you want to search. Should be one of "class" and "field".
If "class", only class names existing in current model will be
searched. If "field", only fields in current model will be
searched. This is a handy option when you want to see if an object
e.g. one material, is referred by other objects e.g.
constructions.
\item \code{...} (in \code{$get}): Valid object IDs. You can find all valid object IDs
using \code{$all("id")}.
}
}

\section{Modify}{
\preformatted{model$add(class, ..., min = TRUE)
model$set(id, ...)
model$dup(id, new_name = NULL)
model$del(id, force = FALSE)
}

\code{$add} will add an object in the \code{class} you give. All fields will be set to
their defaults if applicable.

\code{$set} will set curtain fields in the objects specified by \code{id}.

\code{$dup} will duplicate current object specified by \code{id}.

\code{$del} will delete current object specified by \code{id}. If the object is
referred by other object(s), an error will given showing the fields that
were referred. You can still delete the object if you want by setting
\code{force} to TRUE.

All newly added, modified and deleted fields will be marked with "(+)", "(~)"
and "(-)" respectively. The valid IDs will be appended after \code{$add} and
\code{$dup}, and the newly added (duplicated) object will have the max ID.
\emph{Note} that the IDs of deleted objects are invalid after \code{$del} and cannot
be applied to methods \code{$set}, \code{$dup} and \code{$del}, of course. However, unless
you save the model, the deleted objects are still there internally but with
a special mark to prevent them accessable. This is done by purpose, in
order to provide a new method call \code{$undo} in the future, which will enable
you to un-delete the objects.

\strong{Arguments}
\itemize{
\item \code{model}: An \code{eplus_model} object.
\item \code{class}: An valid class name. Only required when \code{type} is set to "field".
you can find all valid class names using \code{$all("class")}.
\item \code{id}: A valid object IDs. You can find all valid object IDs using
\code{$all("id")}.
\item \code{min}: If TRUE, only minimum fields will be created. Else,
all valid fields will be created. Default is TRUE.
\item \code{new_name}: The new name of the duplicated object if applicable. If NULL,
the duplicated object will have the same name of the original
object except with a suffix of "_1", "_2" and etc.
\item \code{force}: Whether delete the object even it has been referred by others.
Default is FALSE.
\item \code{...}: Field values you want to add or modify. Currently three types are
acceptable: (a) directly list all field values with no name. The
values will be assigned to fields according to the order of values;
(b) give both field names and values in pair, e.g. Name = "Test",
\code{Sepcific Heat} = 150. You can find all valid field names (with
units) using \code{$all("field", class = "class_name_to_query")}; (c)
some kind of the same as (b), but with all field names in lower
cases and spaces replaced by "_". Note: All field names should be
given without units. Error will occur when the type (character or
numeric), and the value (e.g. range) are not valid.
}
}

\section{Diff}{
\preformatted{model$diff(type)
}

\code{$diff} will show all modifications you made, including added (or
duplicated), modified and deleted objects with markers "(+)", "(~)", "(-)"
respectively.

\strong{Arguments}
\itemize{
\item \code{model}: An \code{eplus_model} object.
\item \code{type}: What type of modifications to show. Should be one of "all", "add",
"set", "del". Default is "all".
}
}

\section{Check}{
\preformatted{model$check()
}

\code{$check} will check the validation of all fields in current model, including
missing required objected and fields, wrong value types, choices,
references, any value range exceeds, invalid autosizable and
autocalculatable fields.

\strong{Arguments}
\itemize{
\item \code{model}: An \code{eplus_model} object.
}
}

\section{Save}{
\preformatted{model$save(comfirm = FALSE, format)
model$saveas(path, format, overwrite = FALSE)
}

\code{$save} is a shortcut of \code{$saveas(path = "the_original_model_path")} and will
overwrite the current file which has a risk of losing your original file and
data. So make sure you have a safe copy of you original model.

\code{$saveas} will save the model as a new file.

\strong{Arguments}
\itemize{
\item \code{model}: An \code{eplus_model} object.
\item \code{comfirm}: Whether to save the model and overwrite the original file.
Default is FALSE.
\item \code{format}: The saving format. Should be one of "asis", "sorted", "ori_top",
and "ori_bot". If "asis", which is the default, the model will be
saved in the same format as it is. If the model does not contain
any format saving option, which is typically the case when the
model was not saved using \code{eplusr} or IDFEditor, the "sorted"
will be used. "sorted", "ori_top" and "ori_bot" are the same as
the save options "Sorted", "Original with New at Top", and
"Original with New at Bottom" in IDFEditor.
\item \code{path}: The path to save the model.
\item \code{overwrite}: Whether to overwrite the file if it already exists. Default is
FALSE.
}
}

\section{Reset}{
\preformatted{model$reset(comfirm = FALSE)
}

\code{$reset} will reset the model to the status when it was last saved using
\code{$save} or \code{$saveas} (if never saved, first read and parsed using
\code{eplus_model$new}) All your modifications will be lost, so use with
caution. It is pretty useful if you messed things up during modifications.
}

\keyword{datasets}
